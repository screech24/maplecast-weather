{"ast":null,"code":"import React,{useState,useEffect}from'react';import{createPortal}from'react-dom';import axios from'axios';import'./LocationSearch.css';import{devLog,debugLog,isDevelopment}from'../utils/devMode';import{searchCanadianLocations,CANADIAN_PROVINCES}from'../utils/canadaLocations';// Canadian provinces mapping for search enhancement\n// Now imported from canadaLocations.js\n// Special location types for enhanced search\n// eslint-disable-next-line no-unused-vars\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const SPECIAL_LOCATION_TYPES=['national park','provincial park','park','reserve','conservation area','wilderness','mountain','lake','river','falls','bay','island','peninsula','glacier','forest','beach','valley','canyon','trail','historic site','monument'];// Canadian postal code regex pattern (A1A 1A1 format)\nconst POSTAL_CODE_REGEX=/\\b[A-Za-z]\\d[A-Za-z][ -]?\\d[A-Za-z]\\d\\b/;// Helper function to check if a string contains a Canadian postal code\nconst containsCanadianPostalCode=term=>{return POSTAL_CODE_REGEX.test(term);};// Helper function to check if a string contains a special location type\nconst containsSpecialLocationType=term=>{const termLower=term.toLowerCase();for(const locationType of SPECIAL_LOCATION_TYPES){if(termLower.includes(locationType)){debugLog('LocationSearch',\"Found special location type in term: \".concat(locationType,\" in \\\"\").concat(term,\"\\\"\"));return locationType;}}return null;};// Helper function to check if a string contains a province reference\nconst containsProvinceReference=term=>{const termLower=term.toLowerCase();// Check for province abbreviations (case insensitive with word boundaries)\nfor(const abbr of Object.keys(CANADIAN_PROVINCES)){// Check for exact abbreviation match (case insensitive)\nif(new RegExp(\"\\\\b\".concat(abbr,\"\\\\b\"),'i').test(term)){debugLog('LocationSearch',\"Found province abbreviation in term: \".concat(abbr,\" in \\\"\").concat(term,\"\\\"\"));return true;}// Also check for abbreviation without word boundaries (e.g., \"ON\" in \"TORONTO\")\nif(termLower.includes(abbr.toLowerCase())){debugLog('LocationSearch',\"Found province abbreviation substring in term: \".concat(abbr,\" in \\\"\").concat(term,\"\\\"\"));return true;}}// Check for province full names (partial matches allowed)\nfor(const province of Object.values(CANADIAN_PROVINCES)){const provinceLower=province.toLowerCase();// Check for exact province name match\nif(termLower.includes(provinceLower)){debugLog('LocationSearch',\"Found province name in term: \".concat(province,\" in \\\"\").concat(term,\"\\\"\"));return true;}// Also check for partial matches of longer province names (at least 3 chars)\nif(province.length>3){// Check for first 3+ characters of province names\nconst provinceStart=provinceLower.substring(0,3);if(termLower.includes(provinceStart)){debugLog('LocationSearch',\"Found partial province match: \".concat(provinceStart,\" in \\\"\").concat(term,\"\\\"\"));return true;}// For multi-word provinces, check each word\nconst provinceWords=provinceLower.split(' ');for(const word of provinceWords){if(word.length>3&&termLower.includes(word)){debugLog('LocationSearch',\"Found province word match: \".concat(word,\" in \\\"\").concat(term,\"\\\"\"));return true;}}}}return false;};// Helper function to enhance search terms for Canadian locations\nconst enhanceCanadianSearch=term=>{const termLower=term.toLowerCase().trim();// If already contains Canada, return as is\nif(termLower.includes('canada')){debugLog('LocationSearch',\"Term already contains 'Canada': \".concat(term));return term;}// If it contains a Canadian postal code, it's definitely Canadian\nif(containsCanadianPostalCode(term)){debugLog('LocationSearch',\"Term contains Canadian postal code: \".concat(term));return\"\".concat(term,\", Canada\");}// Check for special location types like parks, mountains, etc.\nconst specialLocationType=containsSpecialLocationType(term);if(specialLocationType){debugLog('LocationSearch',\"Term contains special location type: \".concat(specialLocationType,\" in \\\"\").concat(term,\"\\\"\"));// For national parks and other special locations, try different formats\nif(specialLocationType==='national park'){return\"\".concat(term,\", Canada\");}// For other special location types, ensure proper formatting\nreturn\"\".concat(term,\", Canada\");}// If it contains a province reference, it's likely Canadian\nif(containsProvinceReference(term)){debugLog('LocationSearch',\"Term contains province reference: \".concat(term));// Check if it already ends with a province abbreviation or name\nlet hasProvinceAtEnd=false;// Check for province abbreviations at the end\nfor(const abbr of Object.keys(CANADIAN_PROVINCES)){if(new RegExp(\"\\\\b\".concat(abbr,\"\\\\b$\"),'i').test(term.trim())){hasProvinceAtEnd=true;break;}}// Check for province names at the end\nif(!hasProvinceAtEnd){for(const province of Object.values(CANADIAN_PROVINCES)){if(new RegExp(\"\\\\b\".concat(province,\"\\\\b$\"),'i').test(term.trim())){hasProvinceAtEnd=true;break;}}}// Add Canada explicitly to improve search results\nif(hasProvinceAtEnd){return\"\".concat(term,\", Canada\");}else{// If province reference is in the middle, ensure proper formatting\nreturn\"\".concat(term,\", Canada\");}}// Otherwise, append Canada to improve search results\ndebugLog('LocationSearch',\"Adding 'Canada' to term: \".concat(term));return\"\".concat(term,\", Canada\");};// Helper function to extract the main location name from a search term\nconst extractLocationName=term=>{debugLog('LocationSearch',\"Extracting location name from: \\\"\".concat(term,\"\\\"\"));// Remove postal codes\nlet cleanTerm=term.replace(POSTAL_CODE_REGEX,'').trim();debugLog('LocationSearch',\"After removing postal codes: \\\"\".concat(cleanTerm,\"\\\"\"));// Remove province abbreviations\nfor(const abbr of Object.keys(CANADIAN_PROVINCES)){const beforeClean=cleanTerm;cleanTerm=cleanTerm.replace(new RegExp(\"\\\\b\".concat(abbr,\"\\\\b\"),'i'),'').trim();if(beforeClean!==cleanTerm){debugLog('LocationSearch',\"Removed province abbreviation \".concat(abbr,\": \\\"\").concat(cleanTerm,\"\\\"\"));}}// Remove province names\nfor(const province of Object.values(CANADIAN_PROVINCES)){const beforeClean=cleanTerm;cleanTerm=cleanTerm.replace(new RegExp(\"\\\\b\".concat(province,\"\\\\b\"),'i'),'').trim();if(beforeClean!==cleanTerm){debugLog('LocationSearch',\"Removed province name \".concat(province,\": \\\"\").concat(cleanTerm,\"\\\"\"));}}// Remove \"Canada\" and common separators\nconst beforeFinalClean=cleanTerm;cleanTerm=cleanTerm.replace(/\\bcanada\\b/i,'').replace(/,|;|\\|/g,'').trim();if(beforeFinalClean!==cleanTerm){debugLog('LocationSearch',\"After removing Canada and separators: \\\"\".concat(cleanTerm,\"\\\"\"));}// If we've removed too much, return original term\nif(!cleanTerm||cleanTerm.length<2){debugLog('LocationSearch',\"Extracted name too short, using original: \\\"\".concat(term,\"\\\"\"));return term.replace(/,|;|\\|/g,'').trim();}debugLog('LocationSearch',\"Final extracted location name: \\\"\".concat(cleanTerm,\"\\\"\"));return cleanTerm;};// Known parks and their provinces - this helps with disambiguation\nconst KNOWN_PARKS={'banff':'AB','jasper':'AB','yoho':'BC','kootenay':'BC','waterton lakes':'AB','glacier':'BC','mount revelstoke':'BC','pacific rim':'BC','gwaii haanas':'BC','wood buffalo':'AB','elk island':'AB','riding mountain':'MB','prince albert':'SK','grasslands':'SK','bruce peninsula':'ON','point pelee':'ON','thousand islands':'ON','georgian bay islands':'ON','pukaskwa':'ON','la mauricie':'QC','forillon':'QC','fundy':'NB','kouchibouguac':'NB','cape breton highlands':'NS','kejimkujik':'NS','prince edward island':'PE','terra nova':'NL','gros morne':'NL','auyuittuq':'NU','quttinirpaaq':'NU','sirmilik':'NU','ukkusiksalik':'NU','tuktut nogait':'NT','nahanni':'NT','aulavik':'NT','ivvavik':'YT','kluane':'YT','vuntut':'YT','monkman':'BC',// Monkman Park is in BC\n'wells gray':'BC','garibaldi':'BC','strathcona':'BC','algonquin':'ON','killarney':'ON','quetico':'ON','la verendrye':'QC','gaspesie':'QC'};// Helper function to find the province for a known park\nconst findKnownParkProvince=parkName=>{// Try exact match first\nif(KNOWN_PARKS[parkName]){debugLog('LocationSearch',\"Found exact match for known park: \".concat(parkName,\" in province \").concat(KNOWN_PARKS[parkName]));return KNOWN_PARKS[parkName];}// Try partial matches\nfor(const[knownPark,province]of Object.entries(KNOWN_PARKS)){if(parkName.includes(knownPark)||knownPark.includes(parkName)){debugLog('LocationSearch',\"Found partial match for known park: \".concat(parkName,\" matches \").concat(knownPark,\" in province \").concat(province));return province;}}return null;};// Generate search terms for special location types like national parks\n// eslint-disable-next-line no-unused-vars\nconst generateSpecialLocationSearchTerms=locationName=>{const terms=[];// Clean the location name to ensure it's usable\nconst cleanName=locationName.trim().replace(/\\s+/g,' ');if(!cleanName)return terms;debugLog('LocationSearch',\"Generating special location search terms for: \\\"\".concat(cleanName,\"\\\"\"));// Check if it's a special location type\nconst specialLocationType=containsSpecialLocationType(cleanName);if(specialLocationType){// For national parks\nif(specialLocationType==='national park'){// Try different variations of the name\nconst baseName=cleanName.replace(/\\bnational park\\b/i,'').trim();// Check if this is a known park with a specific province\nconst lowerBaseName=baseName.toLowerCase();const knownProvince=findKnownParkProvince(lowerBaseName);if(knownProvince){// If it's a known park, prioritize the correct province\nconst provinceName=CANADIAN_PROVINCES[knownProvince];terms.push(\"\".concat(baseName,\" National Park, \").concat(provinceName,\", Canada\"));terms.push(\"\".concat(baseName,\", \").concat(provinceName,\", Canada\"));terms.push(\"\".concat(baseName,\" National Park, Canada\"));}else{// Add with explicit \"National Park\" designation\nterms.push(\"\".concat(baseName,\" National Park, Canada\"));// Try with each province, prioritizing western provinces for parks\nconst priorityProvinces=['BC','AB','YT','NT'];// First try priority provinces\nfor(const abbr of priorityProvinces){const province=CANADIAN_PROVINCES[abbr];terms.push(\"\".concat(baseName,\" National Park, \").concat(province,\", Canada\"));}// Then try other provinces\nfor(const[abbr,province]of Object.entries(CANADIAN_PROVINCES)){if(!priorityProvinces.includes(abbr)){terms.push(\"\".concat(baseName,\" National Park, \").concat(province,\", Canada\"));}}}// Try without \"National Park\" designation\nterms.push(\"\".concat(baseName,\", Canada\"));}// For provincial parks\nelse if(specialLocationType==='provincial park'){const baseName=cleanName.replace(/\\bprovincial park\\b/i,'').trim();// Check if this is a known park with a specific province\nconst lowerBaseName=baseName.toLowerCase();const knownProvince=findKnownParkProvince(lowerBaseName);if(knownProvince){// If it's a known park, prioritize the correct province\nconst provinceName=CANADIAN_PROVINCES[knownProvince];terms.push(\"\".concat(baseName,\" Provincial Park, \").concat(provinceName,\", Canada\"));terms.push(\"\".concat(baseName,\", \").concat(provinceName,\", Canada\"));terms.push(\"\".concat(baseName,\" Provincial Park, Canada\"));}else{// Add with explicit \"Provincial Park\" designation\nterms.push(\"\".concat(baseName,\" Provincial Park, Canada\"));// Try with each province\nfor(const[,province]of Object.entries(CANADIAN_PROVINCES)){terms.push(\"\".concat(baseName,\" Provincial Park, \").concat(province,\", Canada\"));}}// Try without \"Provincial Park\" designation\nterms.push(\"\".concat(baseName,\", Canada\"));}// For other parks\nelse if(specialLocationType==='park'){const baseName=cleanName.replace(/\\bpark\\b/i,'').trim();// Check if this is a known park with a specific province\nconst lowerBaseName=baseName.toLowerCase();const knownProvince=findKnownParkProvince(lowerBaseName);if(knownProvince){// If it's a known park, prioritize the correct province\nconst provinceName=CANADIAN_PROVINCES[knownProvince];terms.push(\"\".concat(baseName,\" Park, \").concat(provinceName,\", Canada\"));terms.push(\"\".concat(baseName,\", \").concat(provinceName,\", Canada\"));terms.push(\"\".concat(baseName,\" Park, Canada\"));}else{// Add with explicit \"Park\" designation\nterms.push(\"\".concat(baseName,\" Park, Canada\"));// Try with each province\nfor(const[,province]of Object.entries(CANADIAN_PROVINCES)){terms.push(\"\".concat(baseName,\" Park, \").concat(province,\", Canada\"));}}// Try without \"Park\" designation\nterms.push(\"\".concat(baseName,\", Canada\"));}// For other special location types\nelse{// Try with the special location type\nterms.push(\"\".concat(cleanName,\", Canada\"));// Check if this is a known location with a specific province\nconst lowerName=cleanName.toLowerCase();const knownProvince=findKnownParkProvince(lowerName);if(knownProvince){// If it's a known location, prioritize the correct province\nconst provinceName=CANADIAN_PROVINCES[knownProvince];terms.push(\"\".concat(cleanName,\", \").concat(provinceName,\", Canada\"));}else{// Try with each province\nfor(const province of Object.values(CANADIAN_PROVINCES)){terms.push(\"\".concat(cleanName,\", \").concat(province,\", Canada\"));}}// Try without the special location type\nconst baseNameParts=cleanName.split(' ');if(baseNameParts.length>1){const baseName=baseNameParts.slice(0,-1).join(' ');terms.push(\"\".concat(baseName,\", Canada\"));}}}else{// If not a special location type, just add the basic term\nterms.push(\"\".concat(cleanName,\", Canada\"));}return terms;};// Generate search terms with different province combinations\n// Separate component for the search results dropdown with portal\nconst SearchResultsDropdown=_ref=>{let{searchResults,onLocationSelect,formatLocationDisplay,searchContainer}=_ref;const[dropdownStyle,setDropdownStyle]=useState({});useEffect(()=>{if(searchContainer){const rect=searchContainer.getBoundingClientRect();setDropdownStyle({position:'fixed',top:\"\".concat(rect.bottom+window.scrollY+8,\"px\"),left:\"\".concat(rect.left+window.scrollX,\"px\"),width:\"\".concat(rect.width,\"px\"),zIndex:9999});}},[searchContainer,searchResults.length]);return/*#__PURE__*/_jsx(\"ul\",{className:\"search-results\",style:dropdownStyle,children:searchResults.map((result,index)=>/*#__PURE__*/_jsxs(\"li\",{onClick:()=>onLocationSelect(result),className:\"search-result-item \".concat(result.country==='CA'?'canadian-location':''),role:\"button\",tabIndex:0,onKeyDown:e=>{if(e.key==='Enter'||e.key===' '){onLocationSelect(result);}},children:[/*#__PURE__*/_jsx(\"span\",{className:\"location-name\",children:formatLocationDisplay(result)}),/*#__PURE__*/_jsx(\"span\",{className:\"select-indicator\",children:\"Select\"})]},index))});};const LocationSearch=_ref2=>{let{apiKey,onLocationSelect,onUseMyLocation,onSearchTermChange}=_ref2;const[searchTerm,setSearchTerm]=useState('');const[searchResults,setSearchResults]=useState([]);const[isSearching,setIsSearching]=useState(false);const[error,setError]=useState(null);const[initialized,setInitialized]=useState(false);// This state is used for tracking search progress and providing feedback\nconst[searchStage,setSearchStage]=useState(0);// Used to track the current search stage for debugging\nconst[alternativeSearchTerms,setAlternativeSearchTerms]=useState([]);useEffect(()=>{// We don't strictly need the API key for Environment Canada search, but keep it for OpenWeatherMap fallback\nsetInitialized(true);setError(null);devLog('LocationSearch','Initialized with Environment Canada location search');},[apiKey]);// Close dropdown when clicking outside\nuseEffect(()=>{const handleClickOutside=event=>{if(searchResults.length>0&&!event.target.closest('.search-results')&&!event.target.closest('.location-search')){setSearchResults([]);}};document.addEventListener('mousedown',handleClickOutside);return()=>{document.removeEventListener('mousedown',handleClickOutside);};},[searchResults.length]);const handleSearchTermChange=e=>{const newTerm=e.target.value;setSearchTerm(newTerm);// Clear search results when user starts typing a new search\nif(searchResults.length>0){setSearchResults([]);}if(onSearchTermChange){onSearchTermChange(newTerm);}};// Function to clear the search box\n// eslint-disable-next-line no-unused-vars\nconst clearSearchBox=()=>{setSearchTerm('');setSearchResults([]);if(onSearchTermChange){onSearchTermChange('');}};// Function to perform a search with a specific term\nconst performSearch=async term=>{devLog('LocationSearch',\"Searching for location: \".concat(term));try{setIsSearching(true);setSearchStage(1);// Use the improved searchCanadianLocations function which now uses Nominatim API\nconst canadianResults=await searchCanadianLocations(term);if(canadianResults.length>0){devLog('LocationSearch',\"Found \".concat(canadianResults.length,\" Canadian locations for search term: \").concat(term));setSearchResults(canadianResults);setSearchStage(2);return;}// If no results, try enhancing the search term\nconst enhancedTerm=enhanceCanadianSearch(term);if(enhancedTerm!==term){devLog('LocationSearch',\"Trying enhanced search term: \".concat(enhancedTerm));setSearchStage(3);const enhancedResults=await searchCanadianLocations(enhancedTerm);if(enhancedResults.length>0){devLog('LocationSearch',\"Found \".concat(enhancedResults.length,\" locations with enhanced term: \").concat(enhancedTerm));setSearchResults(enhancedResults);setSearchStage(4);return;}}// If still no results, fall back to OpenWeatherMap API as a last resort\nif(apiKey){devLog('LocationSearch',\"Falling back to OpenWeatherMap API for: \".concat(enhancedTerm));setSearchStage(5);// Log the exact URL being called for debugging\nconst searchUrl=\"https://api.openweathermap.org/geo/1.0/direct?q=\".concat(encodeURIComponent(enhancedTerm),\"&limit=10&appid=\").concat(apiKey);debugLog('LocationSearch',\"Fallback search URL: \".concat(searchUrl));const response=await axios.get(searchUrl);if(response.data.length>0){devLog('LocationSearch',\"Found \".concat(response.data.length,\" locations from OpenWeatherMap for: \").concat(enhancedTerm));// Format OpenWeatherMap results to match our structure\nconst formattedResults=response.data.map(result=>({name:result.name,province:result.state||'',provinceCode:result.state||'',country:result.country,countryCode:result.country,lat:result.lat,lon:result.lon,type:'city',source:'openweathermap'}));// Filter to only Canadian results if possible\nconst canadianResults=formattedResults.filter(result=>result.country==='CA');if(canadianResults.length>0){setSearchResults(canadianResults);}else{// If no Canadian results, use all results\nsetSearchResults(formattedResults);}setSearchStage(6);return;}}// If we get here, no results were found\ndevLog('LocationSearch',\"No results found for: \".concat(term));setSearchResults([]);setError(\"No locations found for \\\"\".concat(term,\"\\\". Try a different search term.\"));setSearchStage(7);// Generate alternative search terms\nconst alternatives=generateAlternativeSearchTerms(term);setAlternativeSearchTerms(alternatives);}catch(error){console.error('Error searching for location:',error);setError(\"Error searching for location: \".concat(error.message));setSearchResults([]);setSearchStage(-1);}finally{setIsSearching(false);}};// Function to generate alternative search terms\nconst generateAlternativeSearchTerms=term=>{const alternatives=[];const cleanTerm=extractLocationName(term);// Add with province codes\nfor(const[code,name]of Object.entries(CANADIAN_PROVINCES)){alternatives.push(\"\".concat(cleanTerm,\", \").concat(code));alternatives.push(\"\".concat(cleanTerm,\", \").concat(name));}// Add with \"Canada\" explicitly\nalternatives.push(\"\".concat(cleanTerm,\", Canada\"));// Return unique alternatives that are different from the original term\nreturn[...new Set(alternatives)].filter(alt=>alt.toLowerCase()!==term.toLowerCase()).slice(0,5);// Limit to 5 alternatives\n};const handleLocationSelect=location=>{devLog('LocationSearch','Location selected:',location);// Ensure we have all required properties before calling the callback\nconst locationData={lat:location.lat,lon:location.lon,name:location.name||'',state:location.province||location.state||'',country:location.country||'Canada',source:location.source||'environment-canada'};// Call the parent component's callback with the location data\nif(onLocationSelect&&typeof onLocationSelect==='function'){onLocationSelect(locationData);// Clear search results after selection\nsetSearchResults([]);// Clear search term\nsetSearchTerm('');}else{devLog('LocationSearch','onLocationSelect is not a function or not provided',{error:true});}};// Format location display for the search results\nconst formatLocationDisplay=result=>{if(!result)return'';let display=result.name||'';// Add province/state if available\nif(result.province){display+=\", \".concat(result.province);}else if(result.state){display+=\", \".concat(result.state);}// Add country if available and not Canada (since we're focusing on Canadian locations)\nif(result.country&&result.country!=='CA'&&result.country!=='Canada'){display+=\", \".concat(result.country);}// Remove source indicators from display\n// No longer showing (nominatim) or other source indicators\nreturn display;};// Handle clicking on an alternative search term\nconst handleAlternativeTermClick=term=>{setSearchTerm(term);performSearch(term);};// Handle search form submission\nconst handleSearch=async e=>{e.preventDefault();const trimmedSearchTerm=searchTerm.trim();if(!trimmedSearchTerm)return;setIsSearching(true);setError(null);setSearchResults([]);setAlternativeSearchTerms([]);devLog('LocationSearch',\"Starting search for: \".concat(trimmedSearchTerm));try{await performSearch(trimmedSearchTerm);}catch(error){console.error('Error in handleSearch:',error);setError(\"Search failed: \".concat(error.message));}finally{setIsSearching(false);}};return/*#__PURE__*/_jsxs(\"div\",{className:\"location-search\",children:[/*#__PURE__*/_jsxs(\"form\",{onSubmit:handleSearch,className:\"search-form\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"search-container\",children:[/*#__PURE__*/_jsx(\"input\",{type:\"text\",value:searchTerm,onChange:handleSearchTermChange,placeholder:initialized?\"Search location...\":\"Initializing...\",className:\"search-input \".concat(!initialized?'disabled':''),disabled:!initialized||isSearching}),/*#__PURE__*/_jsx(\"button\",{type:\"submit\",className:\"search-button\",disabled:!initialized||isSearching||!searchTerm.trim(),children:isSearching?/*#__PURE__*/_jsx(\"span\",{className:\"loading-dot\"}):/*#__PURE__*/_jsx(\"span\",{className:\"search-icon\"})})]}),/*#__PURE__*/_jsxs(\"button\",{type:\"button\",className:\"location-button\",onClick:onUseMyLocation,children:[/*#__PURE__*/_jsx(\"span\",{className:\"location-dot\"}),\" Use my location\"]})]}),error&&/*#__PURE__*/_jsx(\"div\",{className:\"search-error\",\"data-search-stage\":searchStage,children:error}),error&&alternativeSearchTerms.length>0&&/*#__PURE__*/_jsxs(\"div\",{className:\"alternative-terms\",children:[/*#__PURE__*/_jsx(\"p\",{children:containsSpecialLocationType(searchTerm)?\"Try searching for this \".concat(containsSpecialLocationType(searchTerm),\" with a specific province:\"):'Try searching with a specific province:'}),/*#__PURE__*/_jsx(\"ul\",{children:alternativeSearchTerms.slice(0,5).map((term,index)=>/*#__PURE__*/_jsx(\"li\",{onClick:()=>handleAlternativeTermClick(term),children:term},index))})]}),searchResults.length>0&&/*#__PURE__*/createPortal(/*#__PURE__*/_jsx(SearchResultsDropdown,{searchResults:searchResults,onLocationSelect:handleLocationSelect,formatLocationDisplay:formatLocationDisplay,searchContainer:document.querySelector('.search-container')}),document.body)]});};export default LocationSearch;","map":{"version":3,"names":["React","useState","useEffect","createPortal","axios","devLog","debugLog","isDevelopment","searchCanadianLocations","CANADIAN_PROVINCES","jsx","_jsx","jsxs","_jsxs","SPECIAL_LOCATION_TYPES","POSTAL_CODE_REGEX","containsCanadianPostalCode","term","test","containsSpecialLocationType","termLower","toLowerCase","locationType","includes","concat","containsProvinceReference","abbr","Object","keys","RegExp","province","values","provinceLower","length","provinceStart","substring","provinceWords","split","word","enhanceCanadianSearch","trim","specialLocationType","hasProvinceAtEnd","extractLocationName","cleanTerm","replace","beforeClean","beforeFinalClean","KNOWN_PARKS","findKnownParkProvince","parkName","knownPark","entries","generateSpecialLocationSearchTerms","locationName","terms","cleanName","baseName","lowerBaseName","knownProvince","provinceName","push","priorityProvinces","lowerName","baseNameParts","slice","join","SearchResultsDropdown","_ref","searchResults","onLocationSelect","formatLocationDisplay","searchContainer","dropdownStyle","setDropdownStyle","rect","getBoundingClientRect","position","top","bottom","window","scrollY","left","scrollX","width","zIndex","className","style","children","map","result","index","onClick","country","role","tabIndex","onKeyDown","e","key","LocationSearch","_ref2","apiKey","onUseMyLocation","onSearchTermChange","searchTerm","setSearchTerm","setSearchResults","isSearching","setIsSearching","error","setError","initialized","setInitialized","searchStage","setSearchStage","alternativeSearchTerms","setAlternativeSearchTerms","handleClickOutside","event","target","closest","document","addEventListener","removeEventListener","handleSearchTermChange","newTerm","value","clearSearchBox","performSearch","canadianResults","enhancedTerm","enhancedResults","searchUrl","encodeURIComponent","response","get","data","formattedResults","name","state","provinceCode","countryCode","lat","lon","type","source","filter","alternatives","generateAlternativeSearchTerms","console","message","code","Set","alt","handleLocationSelect","location","locationData","display","handleAlternativeTermClick","handleSearch","preventDefault","trimmedSearchTerm","onSubmit","onChange","placeholder","disabled","querySelector","body"],"sources":["/home/jesse/Desktop/Weather Project/maplecast/src/components/LocationSearch.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport axios from 'axios';\nimport './LocationSearch.css';\nimport { devLog, debugLog, isDevelopment } from '../utils/devMode';\nimport { searchCanadianLocations, CANADIAN_PROVINCES } from '../utils/canadaLocations';\n\n// Canadian provinces mapping for search enhancement\n// Now imported from canadaLocations.js\n\n// Special location types for enhanced search\n// eslint-disable-next-line no-unused-vars\nconst SPECIAL_LOCATION_TYPES = [\n  'national park',\n  'provincial park',\n  'park',\n  'reserve',\n  'conservation area',\n  'wilderness',\n  'mountain',\n  'lake',\n  'river',\n  'falls',\n  'bay',\n  'island',\n  'peninsula',\n  'glacier',\n  'forest',\n  'beach',\n  'valley',\n  'canyon',\n  'trail',\n  'historic site',\n  'monument'\n];\n\n// Canadian postal code regex pattern (A1A 1A1 format)\nconst POSTAL_CODE_REGEX = /\\b[A-Za-z]\\d[A-Za-z][ -]?\\d[A-Za-z]\\d\\b/;\n\n// Helper function to check if a string contains a Canadian postal code\nconst containsCanadianPostalCode = (term) => {\n  return POSTAL_CODE_REGEX.test(term);\n};\n\n// Helper function to check if a string contains a special location type\nconst containsSpecialLocationType = (term) => {\n  const termLower = term.toLowerCase();\n  \n  for (const locationType of SPECIAL_LOCATION_TYPES) {\n    if (termLower.includes(locationType)) {\n      debugLog('LocationSearch', `Found special location type in term: ${locationType} in \"${term}\"`);\n      return locationType;\n    }\n  }\n  \n  return null;\n};\n\n// Helper function to check if a string contains a province reference\nconst containsProvinceReference = (term) => {\n  const termLower = term.toLowerCase();\n  \n  // Check for province abbreviations (case insensitive with word boundaries)\n  for (const abbr of Object.keys(CANADIAN_PROVINCES)) {\n    // Check for exact abbreviation match (case insensitive)\n    if (new RegExp(`\\\\b${abbr}\\\\b`, 'i').test(term)) {\n      debugLog('LocationSearch', `Found province abbreviation in term: ${abbr} in \"${term}\"`);\n      return true;\n    }\n    \n    // Also check for abbreviation without word boundaries (e.g., \"ON\" in \"TORONTO\")\n    if (termLower.includes(abbr.toLowerCase())) {\n      debugLog('LocationSearch', `Found province abbreviation substring in term: ${abbr} in \"${term}\"`);\n      return true;\n    }\n  }\n  \n  // Check for province full names (partial matches allowed)\n  for (const province of Object.values(CANADIAN_PROVINCES)) {\n    const provinceLower = province.toLowerCase();\n    \n    // Check for exact province name match\n    if (termLower.includes(provinceLower)) {\n      debugLog('LocationSearch', `Found province name in term: ${province} in \"${term}\"`);\n      return true;\n    }\n    \n    // Also check for partial matches of longer province names (at least 3 chars)\n    if (province.length > 3) {\n      // Check for first 3+ characters of province names\n      const provinceStart = provinceLower.substring(0, 3);\n      if (termLower.includes(provinceStart)) {\n        debugLog('LocationSearch', `Found partial province match: ${provinceStart} in \"${term}\"`);\n        return true;\n      }\n      \n      // For multi-word provinces, check each word\n      const provinceWords = provinceLower.split(' ');\n      for (const word of provinceWords) {\n        if (word.length > 3 && termLower.includes(word)) {\n          debugLog('LocationSearch', `Found province word match: ${word} in \"${term}\"`);\n          return true;\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Helper function to enhance search terms for Canadian locations\nconst enhanceCanadianSearch = (term) => {\n  const termLower = term.toLowerCase().trim();\n  \n  // If already contains Canada, return as is\n  if (termLower.includes('canada')) {\n    debugLog('LocationSearch', `Term already contains 'Canada': ${term}`);\n    return term;\n  }\n  \n  // If it contains a Canadian postal code, it's definitely Canadian\n  if (containsCanadianPostalCode(term)) {\n    debugLog('LocationSearch', `Term contains Canadian postal code: ${term}`);\n    return `${term}, Canada`;\n  }\n  \n  // Check for special location types like parks, mountains, etc.\n  const specialLocationType = containsSpecialLocationType(term);\n  if (specialLocationType) {\n    debugLog('LocationSearch', `Term contains special location type: ${specialLocationType} in \"${term}\"`);\n    \n    // For national parks and other special locations, try different formats\n    if (specialLocationType === 'national park') {\n      return `${term}, Canada`;\n    }\n    \n    // For other special location types, ensure proper formatting\n    return `${term}, Canada`;\n  }\n  \n  // If it contains a province reference, it's likely Canadian\n  if (containsProvinceReference(term)) {\n    debugLog('LocationSearch', `Term contains province reference: ${term}`);\n    \n    // Check if it already ends with a province abbreviation or name\n    let hasProvinceAtEnd = false;\n    \n    // Check for province abbreviations at the end\n    for (const abbr of Object.keys(CANADIAN_PROVINCES)) {\n      if (new RegExp(`\\\\b${abbr}\\\\b$`, 'i').test(term.trim())) {\n        hasProvinceAtEnd = true;\n        break;\n      }\n    }\n    \n    // Check for province names at the end\n    if (!hasProvinceAtEnd) {\n      for (const province of Object.values(CANADIAN_PROVINCES)) {\n        if (new RegExp(`\\\\b${province}\\\\b$`, 'i').test(term.trim())) {\n          hasProvinceAtEnd = true;\n          break;\n        }\n      }\n    }\n    \n    // Add Canada explicitly to improve search results\n    if (hasProvinceAtEnd) {\n      return `${term}, Canada`;\n    } else {\n      // If province reference is in the middle, ensure proper formatting\n      return `${term}, Canada`;\n    }\n  }\n  \n  // Otherwise, append Canada to improve search results\n  debugLog('LocationSearch', `Adding 'Canada' to term: ${term}`);\n  return `${term}, Canada`;\n};\n\n// Helper function to extract the main location name from a search term\nconst extractLocationName = (term) => {\n  debugLog('LocationSearch', `Extracting location name from: \"${term}\"`);\n  \n  // Remove postal codes\n  let cleanTerm = term.replace(POSTAL_CODE_REGEX, '').trim();\n  debugLog('LocationSearch', `After removing postal codes: \"${cleanTerm}\"`);\n  \n  // Remove province abbreviations\n  for (const abbr of Object.keys(CANADIAN_PROVINCES)) {\n    const beforeClean = cleanTerm;\n    cleanTerm = cleanTerm.replace(new RegExp(`\\\\b${abbr}\\\\b`, 'i'), '').trim();\n    if (beforeClean !== cleanTerm) {\n      debugLog('LocationSearch', `Removed province abbreviation ${abbr}: \"${cleanTerm}\"`);\n    }\n  }\n  \n  // Remove province names\n  for (const province of Object.values(CANADIAN_PROVINCES)) {\n    const beforeClean = cleanTerm;\n    cleanTerm = cleanTerm.replace(new RegExp(`\\\\b${province}\\\\b`, 'i'), '').trim();\n    if (beforeClean !== cleanTerm) {\n      debugLog('LocationSearch', `Removed province name ${province}: \"${cleanTerm}\"`);\n    }\n  }\n  \n  // Remove \"Canada\" and common separators\n  const beforeFinalClean = cleanTerm;\n  cleanTerm = cleanTerm.replace(/\\bcanada\\b/i, '')\n                       .replace(/,|;|\\|/g, '')\n                       .trim();\n  \n  if (beforeFinalClean !== cleanTerm) {\n    debugLog('LocationSearch', `After removing Canada and separators: \"${cleanTerm}\"`);\n  }\n  \n  // If we've removed too much, return original term\n  if (!cleanTerm || cleanTerm.length < 2) {\n    debugLog('LocationSearch', `Extracted name too short, using original: \"${term}\"`);\n    return term.replace(/,|;|\\|/g, '').trim();\n  }\n  \n  debugLog('LocationSearch', `Final extracted location name: \"${cleanTerm}\"`);\n  return cleanTerm;\n};\n\n// Known parks and their provinces - this helps with disambiguation\nconst KNOWN_PARKS = {\n  'banff': 'AB',\n  'jasper': 'AB',\n  'yoho': 'BC',\n  'kootenay': 'BC',\n  'waterton lakes': 'AB',\n  'glacier': 'BC',\n  'mount revelstoke': 'BC',\n  'pacific rim': 'BC',\n  'gwaii haanas': 'BC',\n  'wood buffalo': 'AB',\n  'elk island': 'AB',\n  'riding mountain': 'MB',\n  'prince albert': 'SK',\n  'grasslands': 'SK',\n  'bruce peninsula': 'ON',\n  'point pelee': 'ON',\n  'thousand islands': 'ON',\n  'georgian bay islands': 'ON',\n  'pukaskwa': 'ON',\n  'la mauricie': 'QC',\n  'forillon': 'QC',\n  'fundy': 'NB',\n  'kouchibouguac': 'NB',\n  'cape breton highlands': 'NS',\n  'kejimkujik': 'NS',\n  'prince edward island': 'PE',\n  'terra nova': 'NL',\n  'gros morne': 'NL',\n  'auyuittuq': 'NU',\n  'quttinirpaaq': 'NU',\n  'sirmilik': 'NU',\n  'ukkusiksalik': 'NU',\n  'tuktut nogait': 'NT',\n  'nahanni': 'NT',\n  'aulavik': 'NT',\n  'ivvavik': 'YT',\n  'kluane': 'YT',\n  'vuntut': 'YT',\n  'monkman': 'BC',  // Monkman Park is in BC\n  'wells gray': 'BC',\n  'garibaldi': 'BC',\n  'strathcona': 'BC',\n  'algonquin': 'ON',\n  'killarney': 'ON',\n  'quetico': 'ON',\n  'la verendrye': 'QC',\n  'gaspesie': 'QC'\n};\n\n// Helper function to find the province for a known park\nconst findKnownParkProvince = (parkName) => {\n  // Try exact match first\n  if (KNOWN_PARKS[parkName]) {\n    debugLog('LocationSearch', `Found exact match for known park: ${parkName} in province ${KNOWN_PARKS[parkName]}`);\n    return KNOWN_PARKS[parkName];\n  }\n  \n  // Try partial matches\n  for (const [knownPark, province] of Object.entries(KNOWN_PARKS)) {\n    if (parkName.includes(knownPark) || knownPark.includes(parkName)) {\n      debugLog('LocationSearch', `Found partial match for known park: ${parkName} matches ${knownPark} in province ${province}`);\n      return province;\n    }\n  }\n  \n  return null;\n};\n\n// Generate search terms for special location types like national parks\n// eslint-disable-next-line no-unused-vars\nconst generateSpecialLocationSearchTerms = (locationName) => {\n  const terms = [];\n  \n  // Clean the location name to ensure it's usable\n  const cleanName = locationName.trim().replace(/\\s+/g, ' ');\n  if (!cleanName) return terms;\n  \n  debugLog('LocationSearch', `Generating special location search terms for: \"${cleanName}\"`);\n  \n  // Check if it's a special location type\n  const specialLocationType = containsSpecialLocationType(cleanName);\n  if (specialLocationType) {\n    // For national parks\n    if (specialLocationType === 'national park') {\n      // Try different variations of the name\n      const baseName = cleanName.replace(/\\bnational park\\b/i, '').trim();\n      \n      // Check if this is a known park with a specific province\n      const lowerBaseName = baseName.toLowerCase();\n      const knownProvince = findKnownParkProvince(lowerBaseName);\n      \n      if (knownProvince) {\n        // If it's a known park, prioritize the correct province\n        const provinceName = CANADIAN_PROVINCES[knownProvince];\n        terms.push(`${baseName} National Park, ${provinceName}, Canada`);\n        terms.push(`${baseName}, ${provinceName}, Canada`);\n        terms.push(`${baseName} National Park, Canada`);\n      } else {\n        // Add with explicit \"National Park\" designation\n        terms.push(`${baseName} National Park, Canada`);\n        \n        // Try with each province, prioritizing western provinces for parks\n        const priorityProvinces = ['BC', 'AB', 'YT', 'NT'];\n        \n        // First try priority provinces\n        for (const abbr of priorityProvinces) {\n          const province = CANADIAN_PROVINCES[abbr];\n          terms.push(`${baseName} National Park, ${province}, Canada`);\n        }\n        \n        // Then try other provinces\n        for (const [abbr, province] of Object.entries(CANADIAN_PROVINCES)) {\n          if (!priorityProvinces.includes(abbr)) {\n            terms.push(`${baseName} National Park, ${province}, Canada`);\n          }\n        }\n      }\n      \n      // Try without \"National Park\" designation\n      terms.push(`${baseName}, Canada`);\n    }\n    // For provincial parks\n    else if (specialLocationType === 'provincial park') {\n      const baseName = cleanName.replace(/\\bprovincial park\\b/i, '').trim();\n      \n      // Check if this is a known park with a specific province\n      const lowerBaseName = baseName.toLowerCase();\n      const knownProvince = findKnownParkProvince(lowerBaseName);\n      \n      if (knownProvince) {\n        // If it's a known park, prioritize the correct province\n        const provinceName = CANADIAN_PROVINCES[knownProvince];\n        terms.push(`${baseName} Provincial Park, ${provinceName}, Canada`);\n        terms.push(`${baseName}, ${provinceName}, Canada`);\n        terms.push(`${baseName} Provincial Park, Canada`);\n      } else {\n        // Add with explicit \"Provincial Park\" designation\n        terms.push(`${baseName} Provincial Park, Canada`);\n        \n        // Try with each province\n        for (const [, province] of Object.entries(CANADIAN_PROVINCES)) {\n          terms.push(`${baseName} Provincial Park, ${province}, Canada`);\n        }\n      }\n      \n      // Try without \"Provincial Park\" designation\n      terms.push(`${baseName}, Canada`);\n    }\n    // For other parks\n    else if (specialLocationType === 'park') {\n      const baseName = cleanName.replace(/\\bpark\\b/i, '').trim();\n      \n      // Check if this is a known park with a specific province\n      const lowerBaseName = baseName.toLowerCase();\n      const knownProvince = findKnownParkProvince(lowerBaseName);\n      \n      if (knownProvince) {\n        // If it's a known park, prioritize the correct province\n        const provinceName = CANADIAN_PROVINCES[knownProvince];\n        terms.push(`${baseName} Park, ${provinceName}, Canada`);\n        terms.push(`${baseName}, ${provinceName}, Canada`);\n        terms.push(`${baseName} Park, Canada`);\n      } else {\n        // Add with explicit \"Park\" designation\n        terms.push(`${baseName} Park, Canada`);\n        \n        // Try with each province\n        for (const [, province] of Object.entries(CANADIAN_PROVINCES)) {\n          terms.push(`${baseName} Park, ${province}, Canada`);\n        }\n      }\n      \n      // Try without \"Park\" designation\n      terms.push(`${baseName}, Canada`);\n    }\n    // For other special location types\n    else {\n      // Try with the special location type\n      terms.push(`${cleanName}, Canada`);\n      \n      // Check if this is a known location with a specific province\n      const lowerName = cleanName.toLowerCase();\n      const knownProvince = findKnownParkProvince(lowerName);\n      \n      if (knownProvince) {\n        // If it's a known location, prioritize the correct province\n        const provinceName = CANADIAN_PROVINCES[knownProvince];\n        terms.push(`${cleanName}, ${provinceName}, Canada`);\n      } else {\n        // Try with each province\n        for (const province of Object.values(CANADIAN_PROVINCES)) {\n          terms.push(`${cleanName}, ${province}, Canada`);\n        }\n      }\n      \n      // Try without the special location type\n      const baseNameParts = cleanName.split(' ');\n      if (baseNameParts.length > 1) {\n        const baseName = baseNameParts.slice(0, -1).join(' ');\n        terms.push(`${baseName}, Canada`);\n      }\n    }\n  } else {\n    // If not a special location type, just add the basic term\n    terms.push(`${cleanName}, Canada`);\n  }\n  \n  return terms;\n};\n\n// Generate search terms with different province combinations\n\n// Separate component for the search results dropdown with portal\nconst SearchResultsDropdown = ({ searchResults, onLocationSelect, formatLocationDisplay, searchContainer }) => {\n  const [dropdownStyle, setDropdownStyle] = useState({});\n\n  useEffect(() => {\n    if (searchContainer) {\n      const rect = searchContainer.getBoundingClientRect();\n      setDropdownStyle({\n        position: 'fixed',\n        top: `${rect.bottom + window.scrollY + 8}px`,\n        left: `${rect.left + window.scrollX}px`,\n        width: `${rect.width}px`,\n        zIndex: 9999\n      });\n    }\n  }, [searchContainer, searchResults.length]);\n\n  return (\n    <ul className=\"search-results\" style={dropdownStyle}>\n      {searchResults.map((result, index) => (\n        <li \n          key={index} \n          onClick={() => onLocationSelect(result)}\n          className={`search-result-item ${result.country === 'CA' ? 'canadian-location' : ''}`}\n          role=\"button\"\n          tabIndex={0}\n          onKeyDown={(e) => {\n            if (e.key === 'Enter' || e.key === ' ') {\n              onLocationSelect(result);\n            }\n          }}\n        >\n          <span className=\"location-name\">{formatLocationDisplay(result)}</span>\n          <span className=\"select-indicator\">Select</span>\n        </li>\n      ))}\n    </ul>\n  );\n};\n\nconst LocationSearch = ({ apiKey, onLocationSelect, onUseMyLocation, onSearchTermChange }) => {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [searchResults, setSearchResults] = useState([]);\n  const [isSearching, setIsSearching] = useState(false);\n  const [error, setError] = useState(null);\n  const [initialized, setInitialized] = useState(false);\n  // This state is used for tracking search progress and providing feedback\n  const [searchStage, setSearchStage] = useState(0); // Used to track the current search stage for debugging\n  const [alternativeSearchTerms, setAlternativeSearchTerms] = useState([]);\n\n  useEffect(() => {\n    // We don't strictly need the API key for Environment Canada search, but keep it for OpenWeatherMap fallback\n    setInitialized(true);\n    setError(null);\n    devLog('LocationSearch', 'Initialized with Environment Canada location search');\n  }, [apiKey]);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (searchResults.length > 0 && !event.target.closest('.search-results') && !event.target.closest('.location-search')) {\n        setSearchResults([]);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [searchResults.length]);\n\n  const handleSearchTermChange = (e) => {\n    const newTerm = e.target.value;\n    setSearchTerm(newTerm);\n    // Clear search results when user starts typing a new search\n    if (searchResults.length > 0) {\n      setSearchResults([]);\n    }\n    if (onSearchTermChange) {\n      onSearchTermChange(newTerm);\n    }\n  };\n\n  // Function to clear the search box\n  // eslint-disable-next-line no-unused-vars\n  const clearSearchBox = () => {\n    setSearchTerm('');\n    setSearchResults([]);\n    if (onSearchTermChange) {\n      onSearchTermChange('');\n    }\n  };\n\n  // Function to perform a search with a specific term\n  const performSearch = async (term) => {\n    devLog('LocationSearch', `Searching for location: ${term}`);\n    \n    try {\n      setIsSearching(true);\n      setSearchStage(1);\n      \n      // Use the improved searchCanadianLocations function which now uses Nominatim API\n      const canadianResults = await searchCanadianLocations(term);\n      \n      if (canadianResults.length > 0) {\n        devLog('LocationSearch', `Found ${canadianResults.length} Canadian locations for search term: ${term}`);\n        setSearchResults(canadianResults);\n        setSearchStage(2);\n        return;\n      }\n      \n      // If no results, try enhancing the search term\n      const enhancedTerm = enhanceCanadianSearch(term);\n      if (enhancedTerm !== term) {\n        devLog('LocationSearch', `Trying enhanced search term: ${enhancedTerm}`);\n        setSearchStage(3);\n        \n        const enhancedResults = await searchCanadianLocations(enhancedTerm);\n        \n        if (enhancedResults.length > 0) {\n          devLog('LocationSearch', `Found ${enhancedResults.length} locations with enhanced term: ${enhancedTerm}`);\n          setSearchResults(enhancedResults);\n          setSearchStage(4);\n          return;\n        }\n      }\n      \n      // If still no results, fall back to OpenWeatherMap API as a last resort\n      if (apiKey) {\n        devLog('LocationSearch', `Falling back to OpenWeatherMap API for: ${enhancedTerm}`);\n        setSearchStage(5);\n        \n        // Log the exact URL being called for debugging\n        const searchUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(enhancedTerm)}&limit=10&appid=${apiKey}`;\n        debugLog('LocationSearch', `Fallback search URL: ${searchUrl}`);\n        \n        const response = await axios.get(searchUrl);\n        \n        if (response.data.length > 0) {\n          devLog('LocationSearch', `Found ${response.data.length} locations from OpenWeatherMap for: ${enhancedTerm}`);\n          \n          // Format OpenWeatherMap results to match our structure\n          const formattedResults = response.data.map(result => ({\n            name: result.name,\n            province: result.state || '',\n            provinceCode: result.state || '',\n            country: result.country,\n            countryCode: result.country,\n            lat: result.lat,\n            lon: result.lon,\n            type: 'city',\n            source: 'openweathermap'\n          }));\n          \n          // Filter to only Canadian results if possible\n          const canadianResults = formattedResults.filter(result => result.country === 'CA');\n          \n          if (canadianResults.length > 0) {\n            setSearchResults(canadianResults);\n          } else {\n            // If no Canadian results, use all results\n            setSearchResults(formattedResults);\n          }\n          \n          setSearchStage(6);\n          return;\n        }\n      }\n      \n      // If we get here, no results were found\n      devLog('LocationSearch', `No results found for: ${term}`);\n      setSearchResults([]);\n      setError(`No locations found for \"${term}\". Try a different search term.`);\n      setSearchStage(7);\n      \n      // Generate alternative search terms\n      const alternatives = generateAlternativeSearchTerms(term);\n      setAlternativeSearchTerms(alternatives);\n      \n    } catch (error) {\n      console.error('Error searching for location:', error);\n      setError(`Error searching for location: ${error.message}`);\n      setSearchResults([]);\n      setSearchStage(-1);\n    } finally {\n      setIsSearching(false);\n    }\n  };\n\n  // Function to generate alternative search terms\n  const generateAlternativeSearchTerms = (term) => {\n    const alternatives = [];\n    const cleanTerm = extractLocationName(term);\n    \n    // Add with province codes\n    for (const [code, name] of Object.entries(CANADIAN_PROVINCES)) {\n      alternatives.push(`${cleanTerm}, ${code}`);\n      alternatives.push(`${cleanTerm}, ${name}`);\n    }\n    \n    // Add with \"Canada\" explicitly\n    alternatives.push(`${cleanTerm}, Canada`);\n    \n    // Return unique alternatives that are different from the original term\n    return [...new Set(alternatives)]\n      .filter(alt => alt.toLowerCase() !== term.toLowerCase())\n      .slice(0, 5); // Limit to 5 alternatives\n  };\n\n  const handleLocationSelect = (location) => {\n    devLog('LocationSearch', 'Location selected:', location);\n    \n    // Ensure we have all required properties before calling the callback\n    const locationData = {\n      lat: location.lat,\n      lon: location.lon,\n      name: location.name || '',\n      state: location.province || location.state || '',\n      country: location.country || 'Canada',\n      source: location.source || 'environment-canada'\n    };\n    \n    // Call the parent component's callback with the location data\n    if (onLocationSelect && typeof onLocationSelect === 'function') {\n      onLocationSelect(locationData);\n      // Clear search results after selection\n      setSearchResults([]);\n      // Clear search term\n      setSearchTerm('');\n    } else {\n      devLog('LocationSearch', 'onLocationSelect is not a function or not provided', { error: true });\n    }\n  };\n\n  // Format location display for the search results\n  const formatLocationDisplay = (result) => {\n    if (!result) return '';\n    \n    let display = result.name || '';\n    \n    // Add province/state if available\n    if (result.province) {\n      display += `, ${result.province}`;\n    } else if (result.state) {\n      display += `, ${result.state}`;\n    }\n    \n    // Add country if available and not Canada (since we're focusing on Canadian locations)\n    if (result.country && result.country !== 'CA' && result.country !== 'Canada') {\n      display += `, ${result.country}`;\n    }\n    \n    // Remove source indicators from display\n    // No longer showing (nominatim) or other source indicators\n    \n    return display;\n  };\n\n  // Handle clicking on an alternative search term\n  const handleAlternativeTermClick = (term) => {\n    setSearchTerm(term);\n    performSearch(term);\n  };\n\n  // Handle search form submission\n  const handleSearch = async (e) => {\n    e.preventDefault();\n    \n    const trimmedSearchTerm = searchTerm.trim();\n    if (!trimmedSearchTerm) return;\n    \n    setIsSearching(true);\n    setError(null);\n    setSearchResults([]);\n    setAlternativeSearchTerms([]);\n    \n    devLog('LocationSearch', `Starting search for: ${trimmedSearchTerm}`);\n    \n    try {\n      await performSearch(trimmedSearchTerm);\n    } catch (error) {\n      console.error('Error in handleSearch:', error);\n      setError(`Search failed: ${error.message}`);\n    } finally {\n      setIsSearching(false);\n    }\n  };\n\n  return (\n    <div className=\"location-search\">\n      <form onSubmit={handleSearch} className=\"search-form\">\n        <div className=\"search-container\">\n          <input\n            type=\"text\"\n            value={searchTerm}\n            onChange={handleSearchTermChange}\n            placeholder={initialized ? \"Search location...\" : \"Initializing...\"}\n            className={`search-input ${!initialized ? 'disabled' : ''}`}\n            disabled={!initialized || isSearching}\n          />\n          <button \n            type=\"submit\" \n            className=\"search-button\" \n            disabled={!initialized || isSearching || !searchTerm.trim()}\n          >\n            {isSearching ? <span className=\"loading-dot\"></span> : <span className=\"search-icon\"></span>}\n          </button>\n        </div>\n        \n        <button\n          type=\"button\"\n          className=\"location-button\"\n          onClick={onUseMyLocation}\n        >\n          <span className=\"location-dot\"></span> Use my location\n        </button>\n      </form>\n\n      {/* Display error message with search stage info for debugging */}\n      {error && <div className=\"search-error\" data-search-stage={searchStage}>{error}</div>}\n\n      {/* Show alternative search suggestions if available and no results found */}\n      {error && alternativeSearchTerms.length > 0 && (\n        <div className=\"alternative-terms\">\n          <p>\n            {containsSpecialLocationType(searchTerm)\n              ? `Try searching for this ${containsSpecialLocationType(searchTerm)} with a specific province:`\n              : 'Try searching with a specific province:'}\n          </p>\n          <ul>\n            {alternativeSearchTerms.slice(0, 5).map((term, index) => (\n              <li key={index} onClick={() => handleAlternativeTermClick(term)}>\n                {term}\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n\n      {/* Use portal for search results to break out of stacking context */}\n      {searchResults.length > 0 && createPortal(\n        <SearchResultsDropdown \n          searchResults={searchResults}\n          onLocationSelect={handleLocationSelect}\n          formatLocationDisplay={formatLocationDisplay}\n          searchContainer={document.querySelector('.search-container')}\n        />,\n        document.body\n      )}\n    </div>\n  );\n};\n\nexport default LocationSearch;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}