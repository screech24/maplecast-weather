{"ast":null,"code":"import _objectSpread from\"/home/jesse/Desktop/Weather Project/maplecast/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Weather Alerts Utility\n * Fetches and manages weather alerts from Environment Canada\n */import{fetchWeatherAlerts as fetchECAlerts}from'./environmentCanadaApi';// Map of Canadian province names to region codes\nconst PROVINCE_TO_REGION_CODE={'Alberta':'ab','British Columbia':'bc','Manitoba':'mb','New Brunswick':'nb','Newfoundland and Labrador':'nl','Northwest Territories':'nt','Nova Scotia':'ns','Nunavut':'nu','Ontario':'on','Prince Edward Island':'pe','Quebec':'qc','Saskatchewan':'sk','Yukon':'yt'};// Cache for storing alerts\nlet alertsCache={data:null,timestamp:null,lastRequestTime:null,locationKey:null,alertHashes:new Set()// Track alert IDs to detect changes\n};// Cache duration: 1 minute (refresh alerts frequently)\nconst ALERT_CACHE_DURATION=1*60*1000;// Request interval: 30 seconds minimum between requests (more responsive)\nconst REQUEST_INTERVAL=30*1000;/**\n * Clear the alerts cache\n */export const clearAlertsCache=()=>{const oldCache=_objectSpread({},alertsCache);alertsCache={data:null,timestamp:null,lastRequestTime:null,locationKey:null,alertHashes:new Set()};console.log('üóëÔ∏è ALERTS CACHE CLEARED. Previous cache:',oldCache);};/**\n * Get region code from province name\n * @param {string} province - Province name or abbreviation\n * @returns {string} Region code\n */export function getRegionCodeForProvince(province){if(!province)return'ca';// Default to all of Canada\n// Normalize the province name\nconst normalizedProvince=province.trim().toLowerCase();// Check for exact matches\nfor(const[key,value]of Object.entries(PROVINCE_TO_REGION_CODE)){if(key.toLowerCase()===normalizedProvince){return value;}}// Check for partial matches\nfor(const[key,value]of Object.entries(PROVINCE_TO_REGION_CODE)){if(normalizedProvince.includes(key.toLowerCase())||key.toLowerCase().includes(normalizedProvince)){return value;}}// Check for abbreviations\nconst abbr=normalizedProvince.substring(0,2);if(Object.values(PROVINCE_TO_REGION_CODE).includes(abbr)){return abbr;}return'ca';// Default to all of Canada\n}/**\n * Check if we should make a new API request based on rate limiting\n * @returns {boolean}\n */const shouldMakeRequest=()=>{if(!alertsCache.lastRequestTime)return true;const timeSinceLastRequest=Date.now()-alertsCache.lastRequestTime;const shouldRequest=timeSinceLastRequest>=REQUEST_INTERVAL;console.log(\"Rate limiting check: time since last request \".concat(Math.round(timeSinceLastRequest/1000),\"s, should request: \").concat(shouldRequest));return shouldRequest;};/**\n * Check if cached data is still valid\n * @param {Object} locationInfo - Location information\n * @returns {boolean}\n */const isCacheValid=locationInfo=>{if(!alertsCache.data||!alertsCache.timestamp||!alertsCache.locationKey){return false;}// Check if location has changed (use consistent key format)\nconst locationKey=locationInfo.lat&&locationInfo.lon?\"\".concat(locationInfo.lat,\",\").concat(locationInfo.lon):'unknown';console.log(\"\\uD83D\\uDD0D Cache check - current key: \".concat(locationKey,\", cached key: \").concat(alertsCache.locationKey));if(locationKey!==alertsCache.locationKey){console.log('üìç Location changed, cache invalid');return false;}// Check cache age\nconst cacheAge=Date.now()-alertsCache.timestamp;const isValid=cacheAge<ALERT_CACHE_DURATION;if(!isValid){console.log(\"Cache expired (age: \".concat(Math.round(cacheAge/1000),\"s)\"));}return isValid;};/**\n * Generate a hash for an alert to detect changes\n */function generateAlertHash(alert){return\"\".concat(alert.title,\"_\").concat(alert.sent,\"_\").concat(alert.severity);}/**\n * Fetch weather alerts from Environment Canada\n * @param {Object} locationInfo - Location info with lat/lon and region/province\n * @returns {Promise<Array>} Array of alert objects\n */export async function fetchWeatherAlerts(locationInfo){if(!locationInfo){console.warn('No location info provided for fetching alerts');return[];}// Determine location key for caching\nconst locationKey=locationInfo.lat&&locationInfo.lon?\"\".concat(locationInfo.lat,\",\").concat(locationInfo.lon):'unknown';console.log(\"\\uD83D\\uDEA8 FETCHING ALERTS for location: \".concat(locationKey),locationInfo);// Check cache first\nif(isCacheValid(locationInfo)){console.log('Returning cached alerts');return alertsCache.data;}// Check rate limiting\nif(!shouldMakeRequest()){console.log('Rate limit reached, returning cached data or empty array');return alertsCache.data||[];}try{let allAlerts=[];// Get province code\nconst provinceCode=locationInfo.state||locationInfo.region?getRegionCodeForProvince(locationInfo.state||locationInfo.region):'ca';// Get location name for filtering\nconst locationName=locationInfo.name||locationInfo.city||null;console.log(\"Fetching EC alerts for province: \".concat(provinceCode,\", location: \").concat(locationName));// Fetch alerts from Environment Canada\nif(locationInfo.lat&&locationInfo.lon&&provinceCode!=='ca'){try{const weatherAlerts=await fetchECAlerts(provinceCode,locationInfo.lat,locationInfo.lon,locationName// Pass location name for area filtering\n);allAlerts=allAlerts.concat(weatherAlerts);console.log(\"EC API returned \".concat(weatherAlerts.length,\" alerts for \").concat(locationName));}catch(error){console.log('Weather alerts failed:',error.message);}}else if(provinceCode==='ca'){console.log('Province not detected, skipping alert fetch');}// No fallback alerts - only show real Environment Canada alerts\nif(allAlerts.length===0){console.log('No active weather alerts for this area');}// Remove duplicates based on title\nconst uniqueAlerts=allAlerts.filter((alert,index,self)=>index===self.findIndex(a=>a.title===alert.title));// Filter out expired alerts\nconst activeAlerts=uniqueAlerts.filter(alert=>{if(!alert.expires)return true;return new Date(alert.expires)>new Date();});// Sort by severity (Severe first)\nconst severityOrder={'Severe':0,'Moderate':1,'Minor':2};activeAlerts.sort((a,b)=>(severityOrder[a.severity]||2)-(severityOrder[b.severity]||2));console.log(\"Returning \".concat(activeAlerts.length,\" active alerts for \").concat(locationKey));// Update cache\nalertsCache.data=activeAlerts;alertsCache.timestamp=Date.now();alertsCache.lastRequestTime=Date.now();alertsCache.locationKey=locationKey;// Update alert hashes\nalertsCache.alertHashes=new Set(activeAlerts.map(generateAlertHash));console.log(\"\\u2705 ALERTS CACHED: \".concat(activeAlerts.length,\" alerts for \").concat(locationKey));return activeAlerts;}catch(error){console.error('Error fetching weather alerts from all sources:',error);// Return cached data if available, otherwise empty array\nif(alertsCache.data&&alertsCache.data.length>0){console.log('Returning cached alerts due to error');return alertsCache.data;}return[];}}/**\n * Check for new alerts and return only new or updated ones\n * @param {Object} locationInfo - Location information\n * @returns {Promise<Object>} Object with newAlerts and updatedAlerts arrays\n */export async function checkForNewAlerts(locationInfo){// Only check if the app is active (document is visible)\nif(document.hidden){console.log('App is not active, skipping alert check');return{newAlerts:[],updatedAlerts:[],removedAlerts:[]};}try{if(!locationInfo){console.log('No location info available');return{newAlerts:[],updatedAlerts:[],removedAlerts:[]};}// Store previous alert hashes\nconst previousHashes=new Set(alertsCache.alertHashes);const previousAlerts=alertsCache.data||[];// Force a fresh fetch\nalertsCache.timestamp=null;const freshAlerts=await fetchWeatherAlerts(locationInfo);const newAlerts=[];const updatedAlerts=[];const removedAlerts=[];// Check for new alerts\nfor(const alert of freshAlerts){const hash=generateAlertHash(alert);if(!previousHashes.has(hash)){// Check if there was an alert with the same title (updated)\nconst existingAlert=previousAlerts.find(a=>a.title===alert.title);if(existingAlert){updatedAlerts.push(alert);}else{newAlerts.push(alert);}}}// Check for removed alerts\nconst currentTitles=new Set(freshAlerts.map(a=>a.title));for(const prevAlert of previousAlerts){if(!currentTitles.has(prevAlert.title)){removedAlerts.push(prevAlert);}}if(newAlerts.length>0){console.log(\"Found \".concat(newAlerts.length,\" new alerts\"));}if(updatedAlerts.length>0){console.log(\"Found \".concat(updatedAlerts.length,\" updated alerts\"));}if(removedAlerts.length>0){console.log(\"Found \".concat(removedAlerts.length,\" removed alerts\"));}return{newAlerts,updatedAlerts,removedAlerts};}catch(error){console.error('Error checking for new alerts:',error);return{newAlerts:[],updatedAlerts:[],removedAlerts:[]};}}/**\n * Register for background sync to check for alerts periodically\n * @returns {Promise<boolean>} Whether registration was successful\n */export async function registerAlertBackgroundSync(){if(!('serviceWorker'in navigator)||!('SyncManager'in window)){console.log('Background sync not supported');return false;}try{const registration=await navigator.serviceWorker.ready;// Register for background sync\nawait registration.sync.register('weather-alerts-sync');console.log('Registered for background sync');// Register for periodic sync if supported\nif('periodicSync'in registration){try{// Check for permission\nconst status=await navigator.permissions.query({name:'periodic-background-sync'});if(status.state==='granted'){// Register for periodic sync every 5 minutes\nawait registration.periodicSync.register('weather-alerts-periodic',{minInterval:5*60*1000});console.log('Registered for periodic background sync');}else{console.log('Periodic background sync permission not granted');}}catch(error){console.error('Error registering for periodic background sync:',error);}}return true;}catch(error){console.error('Error registering for background sync:',error);return false;}}/**\n * Get region codes to try based on location\n * @param {Object} locationInfo - Location information\n * @returns {string[]} Array of region codes to try\n */export function getRegionCodes(locationInfo){if(!locationInfo||!locationInfo.region){return['ca'];// Default to all of Canada\n}const regionCode=getRegionCodeForProvince(locationInfo.region);return[regionCode,'ca'];// Try specific region first, then all of Canada\n}const alertUtils={fetchWeatherAlerts,checkForNewAlerts,registerAlertBackgroundSync,getRegionCodeForProvince,getRegionCodes,clearAlertsCache};export default alertUtils;","map":{"version":3,"names":["fetchWeatherAlerts","fetchECAlerts","PROVINCE_TO_REGION_CODE","alertsCache","data","timestamp","lastRequestTime","locationKey","alertHashes","Set","ALERT_CACHE_DURATION","REQUEST_INTERVAL","clearAlertsCache","oldCache","_objectSpread","console","log","getRegionCodeForProvince","province","normalizedProvince","trim","toLowerCase","key","value","Object","entries","includes","abbr","substring","values","shouldMakeRequest","timeSinceLastRequest","Date","now","shouldRequest","concat","Math","round","isCacheValid","locationInfo","lat","lon","cacheAge","isValid","generateAlertHash","alert","title","sent","severity","warn","allAlerts","provinceCode","state","region","locationName","name","city","weatherAlerts","length","error","message","uniqueAlerts","filter","index","self","findIndex","a","activeAlerts","expires","severityOrder","sort","b","map","checkForNewAlerts","document","hidden","newAlerts","updatedAlerts","removedAlerts","previousHashes","previousAlerts","freshAlerts","hash","has","existingAlert","find","push","currentTitles","prevAlert","registerAlertBackgroundSync","navigator","window","registration","serviceWorker","ready","sync","register","status","permissions","query","periodicSync","minInterval","getRegionCodes","regionCode","alertUtils"],"sources":["/home/jesse/Desktop/Weather Project/maplecast/src/utils/alertUtils.js"],"sourcesContent":["/**\n * Weather Alerts Utility\n * Fetches and manages weather alerts from Environment Canada\n */\n\nimport { fetchWeatherAlerts as fetchECAlerts } from './environmentCanadaApi';\n\n// Map of Canadian province names to region codes\nconst PROVINCE_TO_REGION_CODE = {\n  'Alberta': 'ab',\n  'British Columbia': 'bc',\n  'Manitoba': 'mb',\n  'New Brunswick': 'nb',\n  'Newfoundland and Labrador': 'nl',\n  'Northwest Territories': 'nt',\n  'Nova Scotia': 'ns',\n  'Nunavut': 'nu',\n  'Ontario': 'on',\n  'Prince Edward Island': 'pe',\n  'Quebec': 'qc',\n  'Saskatchewan': 'sk',\n  'Yukon': 'yt'\n};\n\n// Cache for storing alerts\nlet alertsCache = {\n  data: null,\n  timestamp: null,\n  lastRequestTime: null,\n  locationKey: null,\n  alertHashes: new Set() // Track alert IDs to detect changes\n};\n\n// Cache duration: 1 minute (refresh alerts frequently)\nconst ALERT_CACHE_DURATION = 1 * 60 * 1000;\n\n// Request interval: 30 seconds minimum between requests (more responsive)\nconst REQUEST_INTERVAL = 30 * 1000;\n\n/**\n * Clear the alerts cache\n */\nexport const clearAlertsCache = () => {\n  const oldCache = { ...alertsCache };\n  alertsCache = {\n    data: null,\n    timestamp: null,\n    lastRequestTime: null,\n    locationKey: null,\n    alertHashes: new Set()\n  };\n  console.log('üóëÔ∏è ALERTS CACHE CLEARED. Previous cache:', oldCache);\n};\n\n/**\n * Get region code from province name\n * @param {string} province - Province name or abbreviation\n * @returns {string} Region code\n */\nexport function getRegionCodeForProvince(province) {\n  if (!province) return 'ca'; // Default to all of Canada\n\n  // Normalize the province name\n  const normalizedProvince = province.trim().toLowerCase();\n\n  // Check for exact matches\n  for (const [key, value] of Object.entries(PROVINCE_TO_REGION_CODE)) {\n    if (key.toLowerCase() === normalizedProvince) {\n      return value;\n    }\n  }\n\n  // Check for partial matches\n  for (const [key, value] of Object.entries(PROVINCE_TO_REGION_CODE)) {\n    if (normalizedProvince.includes(key.toLowerCase()) || key.toLowerCase().includes(normalizedProvince)) {\n      return value;\n    }\n  }\n\n  // Check for abbreviations\n  const abbr = normalizedProvince.substring(0, 2);\n  if (Object.values(PROVINCE_TO_REGION_CODE).includes(abbr)) {\n    return abbr;\n  }\n\n  return 'ca'; // Default to all of Canada\n}\n\n/**\n * Check if we should make a new API request based on rate limiting\n * @returns {boolean}\n */\nconst shouldMakeRequest = () => {\n  if (!alertsCache.lastRequestTime) return true;\n  const timeSinceLastRequest = Date.now() - alertsCache.lastRequestTime;\n  const shouldRequest = timeSinceLastRequest >= REQUEST_INTERVAL;\n  console.log(`Rate limiting check: time since last request ${Math.round(timeSinceLastRequest/1000)}s, should request: ${shouldRequest}`);\n  return shouldRequest;\n};\n\n/**\n * Check if cached data is still valid\n * @param {Object} locationInfo - Location information\n * @returns {boolean}\n */\nconst isCacheValid = (locationInfo) => {\n  if (!alertsCache.data || !alertsCache.timestamp || !alertsCache.locationKey) {\n    return false;\n  }\n\n  // Check if location has changed (use consistent key format)\n  const locationKey = locationInfo.lat && locationInfo.lon\n    ? `${locationInfo.lat},${locationInfo.lon}`\n    : 'unknown';\n\n  console.log(`üîç Cache check - current key: ${locationKey}, cached key: ${alertsCache.locationKey}`);\n\n  if (locationKey !== alertsCache.locationKey) {\n    console.log('üìç Location changed, cache invalid');\n    return false;\n  }\n\n  // Check cache age\n  const cacheAge = Date.now() - alertsCache.timestamp;\n  const isValid = cacheAge < ALERT_CACHE_DURATION;\n\n  if (!isValid) {\n    console.log(`Cache expired (age: ${Math.round(cacheAge / 1000)}s)`);\n  }\n\n  return isValid;\n};\n\n/**\n * Generate a hash for an alert to detect changes\n */\nfunction generateAlertHash(alert) {\n  return `${alert.title}_${alert.sent}_${alert.severity}`;\n}\n\n/**\n * Fetch weather alerts from Environment Canada\n * @param {Object} locationInfo - Location info with lat/lon and region/province\n * @returns {Promise<Array>} Array of alert objects\n */\nexport async function fetchWeatherAlerts(locationInfo) {\n  if (!locationInfo) {\n    console.warn('No location info provided for fetching alerts');\n    return [];\n  }\n\n  // Determine location key for caching\n  const locationKey = locationInfo.lat && locationInfo.lon\n    ? `${locationInfo.lat},${locationInfo.lon}`\n    : 'unknown';\n\n  console.log(`üö® FETCHING ALERTS for location: ${locationKey}`, locationInfo);\n\n  // Check cache first\n  if (isCacheValid(locationInfo)) {\n    console.log('Returning cached alerts');\n    return alertsCache.data;\n  }\n\n  // Check rate limiting\n  if (!shouldMakeRequest()) {\n    console.log('Rate limit reached, returning cached data or empty array');\n    return alertsCache.data || [];\n  }\n\n  try {\n    let allAlerts = [];\n\n    // Get province code\n    const provinceCode = locationInfo.state || locationInfo.region\n      ? getRegionCodeForProvince(locationInfo.state || locationInfo.region)\n      : 'ca';\n\n    // Get location name for filtering\n    const locationName = locationInfo.name || locationInfo.city || null;\n\n    console.log(`Fetching EC alerts for province: ${provinceCode}, location: ${locationName}`);\n\n    // Fetch alerts from Environment Canada\n    if (locationInfo.lat && locationInfo.lon && provinceCode !== 'ca') {\n      try {\n        const weatherAlerts = await fetchECAlerts(\n          provinceCode,\n          locationInfo.lat,\n          locationInfo.lon,\n          locationName  // Pass location name for area filtering\n        );\n        allAlerts = allAlerts.concat(weatherAlerts);\n        console.log(`EC API returned ${weatherAlerts.length} alerts for ${locationName}`);\n      } catch (error) {\n        console.log('Weather alerts failed:', error.message);\n      }\n    } else if (provinceCode === 'ca') {\n      console.log('Province not detected, skipping alert fetch');\n    }\n\n    // No fallback alerts - only show real Environment Canada alerts\n    if (allAlerts.length === 0) {\n      console.log('No active weather alerts for this area');\n    }\n\n    // Remove duplicates based on title\n    const uniqueAlerts = allAlerts.filter((alert, index, self) =>\n      index === self.findIndex((a) => a.title === alert.title)\n    );\n\n    // Filter out expired alerts\n    const activeAlerts = uniqueAlerts.filter(alert => {\n      if (!alert.expires) return true;\n      return new Date(alert.expires) > new Date();\n    });\n\n    // Sort by severity (Severe first)\n    const severityOrder = { 'Severe': 0, 'Moderate': 1, 'Minor': 2 };\n    activeAlerts.sort((a, b) => (severityOrder[a.severity] || 2) - (severityOrder[b.severity] || 2));\n\n    console.log(`Returning ${activeAlerts.length} active alerts for ${locationKey}`);\n\n    // Update cache\n    alertsCache.data = activeAlerts;\n    alertsCache.timestamp = Date.now();\n    alertsCache.lastRequestTime = Date.now();\n    alertsCache.locationKey = locationKey;\n\n    // Update alert hashes\n    alertsCache.alertHashes = new Set(activeAlerts.map(generateAlertHash));\n\n    console.log(`‚úÖ ALERTS CACHED: ${activeAlerts.length} alerts for ${locationKey}`);\n\n    return activeAlerts;\n\n  } catch (error) {\n    console.error('Error fetching weather alerts from all sources:', error);\n\n    // Return cached data if available, otherwise empty array\n    if (alertsCache.data && alertsCache.data.length > 0) {\n      console.log('Returning cached alerts due to error');\n      return alertsCache.data;\n    }\n\n    return [];\n  }\n}\n\n/**\n * Check for new alerts and return only new or updated ones\n * @param {Object} locationInfo - Location information\n * @returns {Promise<Object>} Object with newAlerts and updatedAlerts arrays\n */\nexport async function checkForNewAlerts(locationInfo) {\n  // Only check if the app is active (document is visible)\n  if (document.hidden) {\n    console.log('App is not active, skipping alert check');\n    return { newAlerts: [], updatedAlerts: [], removedAlerts: [] };\n  }\n\n  try {\n    if (!locationInfo) {\n      console.log('No location info available');\n      return { newAlerts: [], updatedAlerts: [], removedAlerts: [] };\n    }\n\n    // Store previous alert hashes\n    const previousHashes = new Set(alertsCache.alertHashes);\n    const previousAlerts = alertsCache.data || [];\n\n    // Force a fresh fetch\n    alertsCache.timestamp = null;\n\n    const freshAlerts = await fetchWeatherAlerts(locationInfo);\n\n    const newAlerts = [];\n    const updatedAlerts = [];\n    const removedAlerts = [];\n\n    // Check for new alerts\n    for (const alert of freshAlerts) {\n      const hash = generateAlertHash(alert);\n      if (!previousHashes.has(hash)) {\n        // Check if there was an alert with the same title (updated)\n        const existingAlert = previousAlerts.find(a => a.title === alert.title);\n        if (existingAlert) {\n          updatedAlerts.push(alert);\n        } else {\n          newAlerts.push(alert);\n        }\n      }\n    }\n\n    // Check for removed alerts\n    const currentTitles = new Set(freshAlerts.map(a => a.title));\n    for (const prevAlert of previousAlerts) {\n      if (!currentTitles.has(prevAlert.title)) {\n        removedAlerts.push(prevAlert);\n      }\n    }\n\n    if (newAlerts.length > 0) {\n      console.log(`Found ${newAlerts.length} new alerts`);\n    }\n    if (updatedAlerts.length > 0) {\n      console.log(`Found ${updatedAlerts.length} updated alerts`);\n    }\n    if (removedAlerts.length > 0) {\n      console.log(`Found ${removedAlerts.length} removed alerts`);\n    }\n\n    return { newAlerts, updatedAlerts, removedAlerts };\n  } catch (error) {\n    console.error('Error checking for new alerts:', error);\n    return { newAlerts: [], updatedAlerts: [], removedAlerts: [] };\n  }\n}\n\n/**\n * Register for background sync to check for alerts periodically\n * @returns {Promise<boolean>} Whether registration was successful\n */\nexport async function registerAlertBackgroundSync() {\n  if (!('serviceWorker' in navigator) || !('SyncManager' in window)) {\n    console.log('Background sync not supported');\n    return false;\n  }\n\n  try {\n    const registration = await navigator.serviceWorker.ready;\n\n    // Register for background sync\n    await registration.sync.register('weather-alerts-sync');\n    console.log('Registered for background sync');\n\n    // Register for periodic sync if supported\n    if ('periodicSync' in registration) {\n      try {\n        // Check for permission\n        const status = await navigator.permissions.query({\n          name: 'periodic-background-sync',\n        });\n\n        if (status.state === 'granted') {\n          // Register for periodic sync every 5 minutes\n          await registration.periodicSync.register('weather-alerts-periodic', {\n            minInterval: 5 * 60 * 1000,\n          });\n          console.log('Registered for periodic background sync');\n        } else {\n          console.log('Periodic background sync permission not granted');\n        }\n      } catch (error) {\n        console.error('Error registering for periodic background sync:', error);\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error registering for background sync:', error);\n    return false;\n  }\n}\n\n/**\n * Get region codes to try based on location\n * @param {Object} locationInfo - Location information\n * @returns {string[]} Array of region codes to try\n */\nexport function getRegionCodes(locationInfo) {\n  if (!locationInfo || !locationInfo.region) {\n    return ['ca']; // Default to all of Canada\n  }\n\n  const regionCode = getRegionCodeForProvince(locationInfo.region);\n  return [regionCode, 'ca']; // Try specific region first, then all of Canada\n}\n\nconst alertUtils = {\n  fetchWeatherAlerts,\n  checkForNewAlerts,\n  registerAlertBackgroundSync,\n  getRegionCodeForProvince,\n  getRegionCodes,\n  clearAlertsCache\n};\n\nexport default alertUtils;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}